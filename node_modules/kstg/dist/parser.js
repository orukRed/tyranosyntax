"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = require("./common");
var lexer_1 = require("./lexer");
var tokens_1 = require("./tokens");
function parseIdentifier(c, s, end) {
    if (end === void 0) { end = tokens_1.EOL; }
    var s0 = common_1.copyState(s);
    var i = {
        type: 'Identifier',
        name: lexer_1.readNonQuoteString(s, end)
    };
    return common_1.addLocation(c, s, s0, i);
}
exports.parseIdentifier = parseIdentifier;
function parseComment(c, s, labelComment) {
    if (labelComment === void 0) { labelComment = false; }
    var s0 = common_1.copyState(s);
    if (!lexer_1.stepIf(s, ';') && !labelComment)
        common_1.e(s, 'expect comment start');
    var n = {
        type: 'Comment',
        raw: lexer_1.readNonQuoteString(s, tokens_1.EOL).trim()
    };
    lexer_1.readNewlines(s);
    return common_1.addLocation(c, s, s0, n);
}
exports.parseComment = parseComment;
function parseLabel(c, s) {
    var s0 = common_1.copyState(s);
    lexer_1.stepIf(s, '*');
    var name = parseIdentifier(c, s, ['|'].concat(c.noCommentLabel ? tokens_1.EOL : []));
    var n = {
        type: 'Label',
        name: name
    };
    if (lexer_1.stepIf(s, '|')) {
        n.comment = parseComment(c, s, true);
    }
    lexer_1.readNewlines(s);
    return common_1.addLocation(c, s, s0, n);
}
exports.parseLabel = parseLabel;
function parseLiteral(c, s) {
    var s0 = common_1.copyState(s);
    var value = '';
    if (lexer_1.curChar(s) !== '"' && lexer_1.curChar(s) !== "'") {
        var rawValue = lexer_1.readNonQuoteString(s, [']', '='].concat(tokens_1.pZs));
        var intValue = parseInt(rawValue);
        value =
            isFinite(intValue) && rawValue.match(/^[0-9]+$/) // only decimal
                ? intValue
                : rawValue;
        if (value === 'true')
            value = true;
        else if (value === 'false')
            value = false;
    }
    else {
        value = lexer_1.readQuotedString(c, s);
        lexer_1.stepChar(s);
    }
    var n = {
        type: 'Literal',
        value: value
    };
    return common_1.addLocation(c, s, s0, n);
}
exports.parseLiteral = parseLiteral;
function parseCommandParameter(c, s) {
    var s0 = common_1.copyState(s);
    var key = parseIdentifier(c, s, [']', '='].concat(tokens_1.pZs).concat(tokens_1.EOL));
    lexer_1.readSpaces(s);
    var n = {
        type: 'CommandParameter',
        name: key
    };
    if (lexer_1.stepIf(s, '=')) {
        lexer_1.readSpaces(s);
        n.value = parseLiteral(c, s);
    }
    return common_1.addLocation(c, s, s0, n);
}
exports.parseCommandParameter = parseCommandParameter;
function parseCommandContent(c, s) {
    var r = [];
    lexer_1.readSpaces(s);
    var i = parseIdentifier(c, s, [']', ''].concat(tokens_1.pZs).concat(tokens_1.EOL));
    lexer_1.readSpaces(s);
    while (!lexer_1.eolAhead(s) && lexer_1.curChar(s) !== ']') {
        r.push(parseCommandParameter(c, s));
        lexer_1.readSpaces(s);
    }
    return [i, r];
}
// EOL after Text is a command in KAGEX...
// So we read a more EOL at Command
function parseCommand(c, s) {
    var _a, _b;
    var s0 = common_1.copyState(s);
    var name = { type: 'Identifier', name: '' };
    var param = [];
    if (lexer_1.stepIf(s, '@')) {
        _a = parseCommandContent(c, s), name = _a[0], param = _a[1];
        lexer_1.readNewlines(s);
    }
    else if (lexer_1.stepIf(s, '[')) {
        _b = parseCommandContent(c, s), name = _b[0], param = _b[1];
        lexer_1.stepIf(s, ']');
        if (lexer_1.nextIs(s, tokens_1.EOL))
            lexer_1.readNewlines(s);
    }
    else {
        common_1.e(s, 'parseCommand fail');
    }
    var n = {
        type: 'Command',
        name: name,
        parameters: param
    };
    return common_1.addLocation(c, s, s0, n);
}
exports.parseCommand = parseCommand;
function parseLiteralFromNonQuotedString(c, s, end) {
    var s0 = common_1.copyState(s);
    var i = {
        type: 'Literal',
        value: lexer_1.readNonQuoteString(s, end)
    };
    return common_1.addLocation(c, s, s0, i);
}
exports.parseLiteralFromNonQuotedString = parseLiteralFromNonQuotedString;
function parseCookedText(c, s) {
    var s0 = common_1.copyState(s);
    var r = {
        type: 'CookedText',
        said: {
            type: 'Literal',
            value: ''
        }
    };
    if (lexer_1.stepIf(s, tokens_1.CJKLSB)) {
        r.name = parseIdentifier(c, s, ['/', tokens_1.CJKRSB]);
        if (lexer_1.stepIf(s, '/')) {
            r.as = parseIdentifier(c, s, [tokens_1.CJKRSB]);
        }
        lexer_1.stepIf(s, tokens_1.CJKRSB);
    }
    r.said = parseLiteralFromNonQuotedString(c, s, ['*', '|', '@', '['].concat(tokens_1.EOL));
    return common_1.addLocation(c, s, s0, r);
}
exports.parseCookedText = parseCookedText;
function parseText(c, s) {
    var s0 = common_1.copyState(s);
    var r = {
        type: 'Text',
        raw: ''
    };
    if (!c.kagex) {
        r.raw = lexer_1.readNonQuoteString(s, ['*', '|', '@', '['].concat(tokens_1.EOL));
    }
    else {
        r.cooked = parseCookedText(c, s);
        r.raw = s.src.substring(s0.ptr, s.ptr);
    }
    return common_1.addLocation(c, s, s0, r);
}
exports.parseText = parseText;
function eolTransform(c, s) {
    var s0 = common_1.copyState(s);
    if (!lexer_1.stepIf(s, tokens_1.EOL))
        common_1.e(s, 'Expect EOL');
    lexer_1.readNewlines(s);
    var n = {
        type: 'Command',
        name: null,
        parameters: []
    };
    return common_1.addLocation(c, s, s0, n);
}
exports.eolTransform = eolTransform;
function parseScript(c, s) {
    var s0 = common_1.copyState(s);
    var st = [];
    while (!lexer_1.nextIs(s, tokens_1.EOF)) {
        switch (lexer_1.curChar(s)) {
            case '[':
            case '@':
                st.push(parseCommand(c, s));
                break;
            case ';':
                var cmt = parseComment(c, s);
                if (c.commentInAST)
                    st.push(cmt);
                break;
            case '*':
                st.push(parseLabel(c, s));
                break;
            case '\r':
            case '\n':
                var vcmd = eolTransform(c, s);
                if (c.kagex)
                    st.push(vcmd);
                break;
            default:
                st.push(parseText(c, s));
                break;
        }
    }
    var n = {
        type: 'Script',
        contents: st
    };
    return common_1.addLocation(c, s, s0, n);
}
exports.parseScript = parseScript;
//# sourceMappingURL=parser.js.map